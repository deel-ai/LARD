import math
import numpy as np

from skspatial.objects import Plane
from skspatial.objects import Point
from skspatial.objects import Vector
from skspatial.objects import Points
from skspatial.objects import Line

from numpy import cross, eye, dot
from scipy.linalg import expm, norm
import pyproj


def cos(valueDegrees):
    """
    Compute the cosine of a value in degrees.
    :param valueDegrees:
    :return:
    """
    if valueDegrees is not None:
        return math.cos(math.radians(float(valueDegrees)))
    else:
        return None

def sin(valueDegrees):
    """
    Compute the sine of a value in degrees.
    :param valueDegrees:
    :return:
    """
    if valueDegrees is not None:
        return math.sin(math.radians(float(valueDegrees)))
    else:
        return None

def ecef2llh(x, y, z):
    """

    convert ECEF coordinates into llh coordinates
    
    :param x:
    :param y:
    :param z:
    :return: Lat Long degrees decimal
    """
    R = 6371010
    t = math.sqrt(x ** 2 + y ** 2 + z ** 2)
    #compute longitude
    if x == 0:
        if y < 0:
            longi = - math.pi/2
            
        else:
            longi = math.pi/2
    
    elif x<0:
        if y>0:
            longi = math.pi + math.atan(y/x) # Check here if 180-x or not, as well as longi = -longi
        else:
            longi = - math.pi + math.atan(y/x)
    
    else:
        
        longi = math.atan(y/x)
            
    #compute latitude
    lat = math.asin(z / t)
    height = t - R
    return math.degrees(lat), math.degrees(longi), height


def llh2ecef(latitude, longitude, altitude):
    """
    
    convert latitude, longitude, height (llh) coordintes into ECEF coordinates
    
    :param latitude:
    :param longitude:
    :param altitude:
    
    :return: x, y and z in ECEF frame
    

    """
    R = 6371010
    x_2 = math.pow(altitude + R, 2) * math.pow(math.cos(math.radians(latitude)), 2) / (
                1 + math.pow(math.tan(math.radians(longitude)), 2))
    x = math.sqrt(x_2)

    y_2 = x_2 * math.pow(math.tan(math.radians(longitude)), 2)
    y = math.sqrt(y_2)
    # print(type(longitude))
    
    if (longitude>-180 and longitude < -90):
        y = -y
        x = -x
        
    elif (longitude>-90 and longitude < 0):
        y = -y
        
    elif (longitude>90 and longitude < 180):
        x = -x
    
    
    z = (altitude + R) * math.sin(math.radians(latitude))
    return x, y, z


def llh_relative2absolute(relative, min_range, max_range):
    return (max_range - min_range) * relative + min_range


def closest_point_on_line(a, b, point):
    
    """
    
    find closest point of another point on a line created by two points a and b 
    
    """

    line = Line(point=a, direction=(b-a))
    point_projected = line.project_point(point)

    return point_projected


def fit_3d_plane_from_points(points):
    """
    return the plane generated by 3 points

    """

    points = Points(points)
    plane = Plane.best_fit(points)

    return plane


def projection_3d_point_on_plane(point, plane):
    """
    
    return the projection of a point on a 3d plan

    """
    point = Point(point)
    point_projected = plane.project_point(point)

    return point_projected


def find_closest_point(point, points):
    """
    
    return the closest point from a set of points to another point

    """
    closest_point = point
    closest_distance = np.inf
    for pt in points:
        dist = Point(Point(point)).distance_point(Point(pt))
        if dist < closest_distance:
            closest_distance = dist
            closest_point = pt
    return closest_point


def find_angle_between_vectors(vec1, vec2):
    return Vector(vec1).angle_between(vec2)

def get_distance_between_2_points(pt1, pt2):
    return Point(Point(pt1)).distance_point(Point(pt2))

def rotate_vector(axis, theta):
    return expm(cross(eye(3), axis / norm(axis) * theta))

def find_center(points):
    return Points(points).mean_center(return_centroid=True)


#inputs: longitude, latitude, x rotation, y rotation, z rotation
#output: yaw, pitch, roll (rotations in the NED frame)
def ecef2body_angles(longitude, latitude, rx, ry, rz):

    N0 = np.array([0, 0, 1])
    E0 = np.array([0, 1, 0])
    D0 = np.array([-1, 0, 0])

    X = np.array([1, 0, 0])
    Y = np.array([0, 1, 0])
    Z = np.array([0, 0, 1])

    x0, y0, z0 = X, Y, Z

    x1 = dot(rotate_vector(z0, rz * np.pi / 180), x0)
    y1 = dot(rotate_vector(z0, rz * np.pi / 180), y0)
    z1 = dot(rotate_vector(z0, rz * np.pi / 180), z0)

    x2 = dot(rotate_vector(y1, ry * np.pi / 180), x1)
    y2 = dot(rotate_vector(y1, ry * np.pi / 180), y1)
    z2 = dot(rotate_vector(y1, ry * np.pi / 180), z1)

    x3 = dot(rotate_vector(x2, rx * np.pi / 180), x2)
    y3 = dot(rotate_vector(x2, rx * np.pi / 180), y2)
    z3 = dot(rotate_vector(x2, rx * np.pi / 180), z2)

    #Définition du repère NED
    E = dot(rotate_vector(N0, longitude * np.pi / 180), E0)
    N = dot(rotate_vector(-E, latitude * np.pi / 180), N0)
    D = np.cross(N, E)
    x0, y0, z0 = N, E, D

    #rotations dans ce repère
    yaw = math.atan2(dot(x3, y0), dot(x3, x0)) * 180 / np.pi
    pitch = math.atan2(-dot(x3, z0), math.sqrt((dot(x3, x0)) ** 2 + (dot(x3, y0)) ** 2)) * 180 / np.pi
    roll = math.atan2(dot(y3, z2), dot(y3, y2)) * 180 / np.pi

    return yaw, pitch, roll


def body2ecef_angles(longitude, latitude, heading, pitch, roll):

    N0 = np.array([0, 0, 1])
    E0 = np.array([0, 1, 0])
    D0 = np.array([-1, 0, 0])

    X = np.array([1, 0, 0])
    Y = np.array([0, 1, 0])
    Z = np.array([0, 0, 1])

    E = dot(rotate_vector(N0, longitude * np.pi / 180), E0)
    N = dot(rotate_vector(-E, latitude * np.pi / 180), N0)
    D = np.cross(N,E)

    x0, y0, z0 = N,E,D

    x1 = dot(rotate_vector(z0, heading * np.pi / 180), x0)
    y1 = dot(rotate_vector(z0, heading * np.pi / 180), y0)
    z1 = dot(rotate_vector(z0, heading * np.pi / 180), z0)

    x2 = dot(rotate_vector(y1, pitch * np.pi / 180), x1)
    y2 = dot(rotate_vector(y1, pitch * np.pi / 180), y1)
    z2 = dot(rotate_vector(y1, pitch * np.pi / 180), z1)

    x3 = dot(rotate_vector(x2, roll * np.pi / 180), x2)
    y3 = dot(rotate_vector(x2, roll * np.pi / 180), y2)
    z3 = dot(rotate_vector(x2, roll * np.pi / 180), z2)

    x0, y0, z0 = X, Y, Z

    rz = math.atan2(dot(x3,y0), dot(x3,x0))*180/np.pi
    ry = math.atan2(-dot(x3,z0), math.sqrt((dot(x3,x0))**2 + (dot(x3,y0))**2))*180/np.pi
    rx = math.atan2(dot(y3,z2), dot(y3,y2))*180/np.pi

    return rz, ry, rx


def find_azimuth_between_2_coordinates(long1, lat1, long2, lat2):
    
    """
    
    :return type: tuple(distance, angle1, angle2)    

    """
    geodesic = pyproj.Geod(ellps='WGS84')
    return geodesic.inv(long1, lat1, long2, lat2)

def forward_pos(long, lat, azimut, dist):
    
    """
    
    return the point at the distance dist from an origin point on the geodesic WGS84 following an azimut angle

    """
    geodesic = pyproj.Geod(ellps='WGS84')
    return geodesic.fwd(long, lat, azimut, dist, radians=False) #back azimut

def adjust_point_projection(points_3d, z):
    """
    Find if the point 3d are in front of the camera (z distance), in case of any of the points are outside of the field
    of view, an  equivalent point shall be found.
    :param points_3d:
    :param z: positive value corresponding to plane in front of the camera.
    :return:
    """
    pointA = [float(points_3d[0][0]), float(points_3d[0][1]), float(points_3d[0][2])]
    pointB = [float(points_3d[1][0]), float(points_3d[1][1]), float(points_3d[1][2])]
    line_equation = Line.from_points(np.array(pointA), np.array(pointB))

    t = (z-pointA[2])/line_equation.vector[2]

    if pointA[2] < z:
        points_3d[0][0] = line_equation.vector[0]*t + pointA[0]
        points_3d[0][1] = line_equation.vector[1]*t + pointA[1]
        points_3d[0][2] = z

    if pointB[2] < z:
        points_3d[1][0] = line_equation.vector[0]*t + pointB[0]
        points_3d[1][1] = line_equation.vector[1]*t + pointB[1]
        points_3d[1][2] = z

    return points_3d


def adjust_index(points_2d, height, width):
    """
    Adjust the points that are outside of the images, finding the intersection with the bounds of the image.
    :param points_2d:
    :param height:
    :param width:
    :return:
    """

    pointA = [float(points_2d[0][0]), float(points_2d[0][1])]
    pointB = [float(points_2d[1][0]), float(points_2d[1][1])]
    line_equation = Line.from_points(np.array(pointA), np.array(pointB))


    #Equation between two points
    if line_equation.vector[0] !=0:
       slope = line_equation.vector[1]/line_equation.vector[0]
       b = line_equation.point[1] - slope*line_equation.point[0]
    else:
        slope = None
        b = None

    inter = np.array([[-1, -1],
                      [-1, -1],
                      [-1, -1],
                      [-1, -1]])
    if slope is not None:
        # TOP
        if b >= 0 and b < height:
            inter[0] = [0, b]

        # RIGHT
        if slope != 0:
            if -b/slope >= 0 and -b/slope < width:
                inter[1] = [-b/slope, 0]

        # BOTTOM
        y = slope*(width-1) + b
        if y >= 0 and y < height:
            inter[2] = [width-1, y]

        # LEFT
        if slope != 0:
            x = (height -1 - b)/slope
            if x >= 0 and x < width:
                inter[3] = [x, height-1]

    if (pointA[0] < 0 or pointA[0] >= width) or (pointA[1] < 0 or pointA[1] >= height):
        points_2d[0] = closest_point(pointA, inter)

    if (pointB[0] < 0 or pointB[0] >= width) or (pointB[1] < 0 or pointB[1] >= height):
        points_2d[1] = closest_point(pointB, inter)

    return points_2d


def closest_point(point_2d, array_points):
    """
    Find the closes point.
    :param point_2d:
    :param array_points:
    :return:
    """
    first_flag = True
    value = None
    for e_inter in array_points:
        if e_inter[0] != -1:
            distance = math.sqrt(math.pow((point_2d[0] - e_inter[0]), 2) + math.pow((point_2d[1] - e_inter[1]), 2))
            if first_flag is True:
                minimal = distance
                value = e_inter
                first_flag = False
            elif distance < minimal:
                value = e_inter
                minimal = distance
    return value
